;; These are a list of commands supported by TinyScheme

lambda
quote
define
if
begin
set!
let
let*
letrec
cond
delay
and
or
cons-stream
macro
case
load
gensym
tracing
make-closure
defined?
eval
apply
call-with-current-continuation
inexact->exact
exp
log
sin
cos
tan
asin
acos
atan
sqrt
expt
floor
ceiling
truncate
round
+
-
*
/
quotient
remainder
modulo
car
cdr
cons
set-car!
set-cdr!
char->integer
integer->char
char-upcase
char-downcase
symbol->string
atom->string
string->symbol
string->atom
make-string
string-length
string-ref
string-set!
string-append
substring
vector
make-vector
vector-length
vector-ref
vector-set!
not
boolean?
eof-object?
null?
=
<
>
<=
>=
symbol?
number?
string?
integer?
real?
char?
char-alphabetic?
char-numeric?
char-whitespace?
char-upper-case?
char-lower-case?
port?
input-port?
output-port?
procedure?
pair?
list?
environment?
vector?
eq?
eqv?
force
write
write-char
display
newline
error
reverse
list*
append
put
get
quit
gc
gc-verbose
new-segment
oblist
current-input-port
current-output-port
open-input-file
open-output-file
open-input-output-file
open-input-string
open-input-output-string
open-output-string
get-output-string
close-input-port
close-output-port
interaction-environment
current-environment
read
read-char
peek-char
char-ready?
set-input-port
set-output-port
length
assq
get-closure-code
closure?
macro?
caar
cadr
cdar
cddr
caaar
caadr
cadar
caddr
cdaar
cdadr
cddar
cdddr
caaaar
caaadr
caadar
caaddr
cadaar
cadadr
caddar
cadddr
cdaaar
cdaadr
cdadar
cdaddr
cddaar
cddadr
cdddar
cddddr
macro-expand
macro-expand-all
exact?
inexact?
even?
odd?
zero?
positive?
negative?
complex?
rational?
abs
exact->inexact
<>
max
min
succ
pred
gcd
lcm
string
list->string
string-fill!
string->list
string-copy
string->anyatom
string->number
anyatom->string
number->string
char-cmp?
char-ci-cmp?
char=?
char<?
char>?
char<=?
char>=?
char-ci=?
char-ci<?
char-ci>?
char-ci<=?
char-ci>=?
string-cmp?
string=?
string<?
string>?
string<=?
string>=?
string-ci=?
string-ci<?
string-ci>?
string-ci<=?
string-ci>=?
list
foldr
unzip1-with-cdr
unzip1-with-cdr-iterative
map
for-each
list-tail
list-ref
last-pair
head
tail
vector-equal?
list->vector
vector-fill!
vector->list
shared-tail
call/cc
atom?
equal?
generic-member
memq
memv
member
generic-assoc
assq
assv
assoc
acons
push-handler
pop-handler)
more-handlers?)
throw
eval-polymorphic
input-output-port?
close-port
call-with-input-file
call-with-output-file
with-input-from-file
with-output-to-file
with-input-output-from-to-files
cond-expand
cond-expand-runtime
cond-eval-and
cond-eval-or
cond-eval
